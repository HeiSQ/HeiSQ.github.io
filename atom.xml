<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>石乔的博客</title>
  
  <subtitle>https://heisq.top/</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://heisq.top/"/>
  <updated>2020-04-08T15:27:13.639Z</updated>
  <id>https://heisq.top/</id>
  
  <author>
    <name>不知名的某乔</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020-面试题整理(面试必问的HashMap)</title>
    <link href="https://heisq.top/posts/d45d4849.html"/>
    <id>https://heisq.top/posts/d45d4849.html</id>
    <published>2020-04-08T15:26:25.792Z</published>
    <updated>2020-04-08T15:27:13.639Z</updated>
    
    <content type="html"><![CDATA[<p>问：</p><pre><code>HashMap的容量是多少？负载因子是什么？容量如何变化？容量不够怎么办</code></pre><p>答：</p><blockquote><p>数组大小是由 capacity 这个参数确定的，默认是16，也可以构造时传入，最大限制是1&lt;&lt;30；<br>loadFactor 是负载因子，主要目的是用来确认table 数组是否需要动态扩展，默认值是0.75，比如table 数组大小为 16，装载因子为 0.75 时，threshold 就是12，当 table 的实际大小超过 12 时，table就需要动态扩容；<br>扩容时，调用 resize() 方法，将 table 长度变为原来的两倍；<br>扩容时创建一个新的数组，其容量为旧数组的两倍，并重新计算旧数组中结点的存储位置；<br>如果数据量很大的情况下，扩容时将会带来性能的损失，在性能要求很高的地方，这种操作性能很低；</p></blockquote><p>问：</p><pre><code>HashMap中put方法的过程</code></pre><p>答：</p><blockquote><ol><li>调用哈希函数获取key对应的hash值，再计算其数组下标；</li><li>如果没有出现哈希冲突，则直接放入数组，如果出现哈希冲突，则以链表的方式放在链表后面；</li><li>如果链表长度超过阈值，就把链表转成红黑树。</li><li>如果节点的key已经存在，则替换其value即可</li><li>如果集合中的键值对大于12，则调用resize（）方法进行数组扩容</li></ol></blockquote><p>问：</p><pre><code>你能跟我聊一下HashMap的数据结构吗？</code></pre><p>答：</p><blockquote><p>可以的，HashMap在jdk1.7和1.8做的比较大的一个改变：1.7之前使用的就是数组加链表，它数据节点是一个Entry节点，就是它的一个内部类，HashMap1.7之前它的数据插入过程是使用了一个头插法,HashMap使用头插法会造成什么问题呢？它扩容的一个过程可能会造成在里面有一个resize的方法，他又调用了一个transfer的方法然后把里面的一些Entry进行了一个rehash，在这些过程中可能会造成链表的一个循环，就可能在下一次get的时候出现死循环的情况，然后也有可能就是因为它没有加锁，所以他也有可能在多个线程并发的情况下对它的数据不能保证是一个安全的，就是我push进去的值取出来还是我push进去的那个值。然后jdk1.8以后对他进行了一个比较大的变化，主要是把它变成了一个链表加数组加红黑树的这么一个结构，把原来的一个Entry节点也变成了一个Node节点，它整个put的过程也做了一个优化。</p></blockquote><p>问：</p><pre><code>你简单说下HashMap的扩容机制吧。</code></pre><p>答：</p><blockquote><p>首先扩容机制我们要了解的就是capacity这个节点，就是我在初始化这个HashMap的时候，如果我们没有设置他的capacity，它的默认初始化容量是16，负载因子是0.75，它会计算出来一个扩容的阈值，如果当我在put的时候会先判断我当前的这个size是不是要大于这个阈值，如果大于的话，它就会扩容成原来的两倍，将原来的一个Entry进行resize，这就是HashMap扩容机制的过程。</p></blockquote><p>问：</p><pre><code>HashMap在jdk1.7头插法的时候，他会有死循环，那个时候是线程不安全的原因之一,那1.8之后，它的线程就安全了吗？</code></pre><p>答：</p><blockquote><p>它也不是线程安全的，因为它虽然采用了尾插法但还是没有改变原来数据插入的顺序，所以在这不会出现链表循环的过程。</p></blockquote><p>问：</p><pre><code>那他线程不安全，你在日常开发中是怎么保证他线程安全的</code></pre><p>答：</p><blockquote><p>我一般会使用ConcurrentHashMap这种线程安全的一个集合容器。</p></blockquote><p>问：</p><pre><code>那线程安全的，还有像HashTable，或者说给他加Synchronized或者lock，或者用Collection.Synchronized都可以对它进行一个同步的操作，为什么你选择了ConcurrentHasMap？</code></pre><p>答：</p><blockquote><p>因为ConcurrentHasMap它的并发度是更高的，就普通的HashTable是直接对里面的方法进行一个Synchronuzed就是加了一个对象锁，但是ConcurrentHashMap数据结构在jdk1.8之后变成了同样的数组加链表加红黑色，它只会锁住我目前获取到的那个Entry所在的那个节点的值，在上锁的时候他使用了CAS加Synchronuzed，再加上jdk1.6之后对Synchronuzed进行了一个优化升级的一个过程，所以它的效率是更高的。</p></blockquote><p>问：</p><pre><code>简单介绍一下Synchronized的原理。</code></pre><p>答：</p><blockquote><p>Synchronized是由JVM实现的一种实现互斥同步的一种方式，如果你查看被Synchronized修饰过的程序块编译后的字节码，会发现，被Synchronized修饰过的程序块，在编译前后被编译器生成了monitorenter和monitorexit两个字节码指令。这两个指令是什么意思呢？在虚拟机执行到monitorenter指令时，首先要尝试获取对象的锁：如果这个对象没有锁定，或者当前线程已经拥有了这个对象的锁，把锁的计数器+1；当执行monitorexit指令时将锁计数器-1；当计数器<br>为0时，锁就被释放了。如果获取对象失败了，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。Java中Synchronize通过在对象头设置标记，达到了获取锁和释放锁的目的。</p></blockquote><p>问：</p><pre><code>简单介绍一下锁升级的过程。</code></pre><p>答：</p><blockquote><p> 首先最开始应该无锁的一个状态，它会先进行一个判断。然后就是这个锁是有支持偏向锁的，当前获取到锁资源的这个过程，我们会优先让它再去获取到这个锁，如果它没有获取到这个锁，就升级成一个轻量级的，一个CAS的锁，就是一个乐观锁，乐观锁它是一个比较与替换的过程，如果这个CAS没有设置成功的话，他会进行一个自旋，自旋到一定的次数之后才会升级成一个Synchronized的这样的一个重量级的锁，这样的话，就保证了它的一个性能的问题；</p></blockquote><p>问：</p><pre><code>jdk8中对HashMap做了哪些改进？</code></pre><p>答：</p><blockquote><ol><li>在1.8中，如果链表的长度超过了8，那么链表将转换为红黑树；</li><li>发生hash碰撞时，1.7会在链表的头部插入，而1.8会在链表的尾部插入；</li><li>在1.8中，Entry被Node替代（换了一个类名）</li></ol></blockquote><p>问：</p><pre><code>HashMap 和 HashTable 有什么区别？</code></pre><p>答：</p><blockquote><ol><li>HashMap是线程不安全的，HashTable是线程安全的，由于线程安全，所以HashTable的效率比不上HashMap；</li><li>HashMap最多只允许一条记录的键为null，允许多条记录的值为null，而HashTable不允许；</li><li>HashMap默认初始化数组的大小为16，HashTable为11，前者扩容时，扩大两倍，后者扩大两倍+1</li><li>HashMap需要重新计算Hash值，而HashTable直接使用对象的HashCode；</li></ol></blockquote><p>问：</p><pre><code>我们能否让HashMap实现同步（线程安全）</code></pre><p>答：</p><blockquote><p>  当然可以，使用Map map = Collections.SynchronizeMap(hashMap)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HashMap的容量是多少？负载因子是什么？容量如何变化？容量不够怎么办&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数组大小是由 capacity 这个参数确定的，默认是16，也可以构造时传入，最大限制是
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>RabbitMQ消息队列_从入门到精通——RabbitMQ的安装与启动</title>
    <link href="https://heisq.top/posts/cf7e4c96.html"/>
    <id>https://heisq.top/posts/cf7e4c96.html</id>
    <published>2020-03-27T12:42:07.753Z</published>
    <updated>2020-03-27T12:50:20.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1章-RabbitMQ安装"><a href="#第1章-RabbitMQ安装" class="headerlink" title="第1章 RabbitMQ安装"></a>第1章 RabbitMQ安装</h1><p>一般来说安装RabbitMQ之前要安装Erlang，可以去Erlang官网下载。<br>接着去RabbitMQ官网下载安装包，之后解压缩即可。<br>Erlang官方下载地址：<a href="https://www.erlang.org/downloads" target="_blank" rel="noopener">https://www.erlang.org/downloads</a><br>RabbitMQ官方下载地址：<a href="https://www.rabbitmq.com/download.html" target="_blank" rel="noopener">https://www.rabbitmq.com/download.html</a><br>不方便去官网下载的可以去<a href="https://pan.baidu.com/s/1fg7XIySTHpL1KltmJ-Wjjg" target="_blank" rel="noopener">百度网盘下载</a>  提取码：cweu<br><img src="https://img-blog.csdnimg.cn/20200327202438625.png" alt="在这里插入图片描述"></p><h2 id="1-1-安装前的准备"><a href="#1-1-安装前的准备" class="headerlink" title="1.1 安装前的准备"></a>1.1 安装前的准备</h2><h3 id="1-1-1-依赖包安装"><a href="#1-1-1-依赖包安装" class="headerlink" title="1.1.1 依赖包安装"></a>1.1.1 依赖包安装</h3><p>安装RabbitMQ之前必须要先安装所需要的依赖包，可以使用下面的一次性安装命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc glibc-devel make ncurses-devel openssl-devel xmlto</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-1-2安装Erlang"><a href="#1-1-2安装Erlang" class="headerlink" title="1.1.2安装Erlang"></a>1.1.2安装Erlang</h3><ol><li>手动在Linux的/usr/local目录下创建Erlang的安装目录</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/erlang</span><br></pre></td></tr></table></figure><ol start="2"><li>将Erlang源代码包otp_src_19.3.tar.gz上传到/usr/local/erlang目录下</li><li>解压erlang 源码包<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf otp_src_19<span class="number">.3</span>.tar.gz</span><br></pre></td></tr></table></figure></li><li>进入erlang的解压目录</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd otp_src_19<span class="number">.3</span></span><br></pre></td></tr></table></figure><ol start="5"><li>配置erlang的安装信息</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/erlang --without-javac</span><br></pre></td></tr></table></figure><ol start="6"><li>编译并安装</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><ol start="7"><li>配置环境变量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><ol start="8"><li>将这些配置填写到profile文件的最后</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERL_HOME=/usr/local/erlang</span><br><span class="line">PATH=$ERL_HOME/bin:$PATH</span><br><span class="line">export ERL_HOME PATH</span><br></pre></td></tr></table></figure><ol start="9"><li>启动环境变量配置文件(启动后不会有提示)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h2 id="1-2-安装RabbitMQ"><a href="#1-2-安装RabbitMQ" class="headerlink" title="1.2 安装RabbitMQ"></a>1.2 安装RabbitMQ</h2><ol><li>将RabbitMQ安装包安装包rabbitmq-server-3.7.2-1.el7.noarch.rpm 上传到/home目录</li><li>安装RabbitMQ</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh --nodeps rabbitmq-server-<span class="number">3.7</span><span class="number">.2</span>-<span class="number">1</span>.el7.noarch.rpm</span><br></pre></td></tr></table></figure><h2 id="1-3-Rabbit常用命令"><a href="#1-3-Rabbit常用命令" class="headerlink" title="1.3 Rabbit常用命令"></a>1.3 Rabbit常用命令</h2><h3 id="1-3-1-启动和关闭"><a href="#1-3-1-启动和关闭" class="headerlink" title="1.3.1 启动和关闭"></a>1.3.1 启动和关闭</h3><ol><li>启动RabbitMQ</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-server start &amp;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里可能会出现错误，错误原因是/var/lib/rabbitmq/.erlang.cookie文件权限不够。 解决方案对这个文件授权<br>chown rabbitmq:rabbitmq /var/lib/rabbitmq/.erlang.cookie chmod 400<br>/var/lib/rabbitmq/.erlang.cookie</p></blockquote><ol start="2"><li>停止服务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop</span><br></pre></td></tr></table></figure><h3 id="1-3-2-插件管理"><a href="#1-3-2-插件管理" class="headerlink" title="1.3.2 插件管理"></a>1.3.2 插件管理</h3><ol><li>添加插件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable &#123;插件名&#125;</span><br></pre></td></tr></table></figure></li><li>删除插件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins disable &#123;插件名&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>注意：RabbitMQ启动以后可以使用浏览器进入管控台但是默认情况RabbitMQ不允许直接使用浏览器浏览器进行访问因此必须添加插件</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure></li><li>使用浏览器访问管控台<a href="http://RabbitMQ服务器IP:15672" target="_blank" rel="noopener">http://RabbitMQ服务器IP:15672</a></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//172.16.188.133:15672</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020032720053355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlaVNR,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="1-3-3-用户管理"><a href="#1-3-3-用户管理" class="headerlink" title="1.3.3 用户管理"></a>1.3.3 用户管理</h3><p>RabbitMQ安装成功后使用默认用户名guest登录</p><blockquote><p>账号：guest<br>密码：guest</p></blockquote><p><em>注意：这里guest只允许本机登录访问需要创建用户并授权远程访问命令如下</em> </p><ol><li>添加用户：<code>rabbitmqctl add_user {username} {password}</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user root root</span><br></pre></td></tr></table></figure><ol start="2"><li>删除用户：<code>rabbitmqctl delete_user {username}</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl delete_user root</span><br></pre></td></tr></table></figure><ol start="3"><li>修改密码：<code>rabbitmqctl change_password {username} {newpassword}</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl change_password root <span class="number">123456</span></span><br></pre></td></tr></table></figure><ol start="4"><li>设置用户角色：<code>rabbitmqctl set_user_tags {username} {tag}</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_user_tags root administrator</span><br></pre></td></tr></table></figure><p>tag参数表示用户角色取值为：<code>management ，monitoring ，policymaker  administrator</code><br>各角色详解：  </p><ul><li><code>management</code><ul><li>用户可以通过AMQP做的任何事外加： </li><li>列出自己可以通过AMQP登入的virtual hosts  </li><li>查看自己的virtual hosts中的queues, exchanges 和 bindings </li><li>查看和关闭自己的channels 和 connections </li><li>查看有关自己的virtual hosts的“全局”的统计信息，包含其他用户在这些virtual<br>hosts中的活动。</li></ul></li><li><code>policymaker</code><ul><li><code>management</code><ul><li>可以做的任何事外加：</li><li>查看、创建和删除自己的virtual hosts所属的policies和parameters</li></ul></li></ul></li><li><code>monitoring</code><ul><li><code>management</code></li><li>可以做的任何事外加： </li><li>列出所有virtual hosts，包括他们不能登录的virtual hosts </li><li>查看其他用户的connections和channels </li><li>查看节点级别的数据如clustering和memory使用情况</li><li>查看真正的关于所有virtual hosts的全局的统计信息</li></ul></li><li><code>administrator</code><ul><li><code>policymaker</code>和<code>monitoring</code>可以做的任何事外加: </li><li>创建和删除virtual hosts</li><li>查看、创建和删除users </li><li>查看创建和删除permissions </li><li>关闭其他用户的connections</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20200327202540959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlaVNR,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="1-3-4-权限管理"><a href="#1-3-4-权限管理" class="headerlink" title="1.3.4 权限管理"></a>1.3.4 权限管理</h3><ol><li>授权命令：<code>rabbitmqctl set_permissions [-p vhostpath] {user} {conf} {write} {read}</code></li></ol><p>-p vhostpath ：用于指定一个资源的命名空间，例如 –p / 表示根路径命名空间<br>user：用于指定要为哪个用户授权填写用户名<br>     conf:一个正则表达式match哪些配置资源能够被该用户配置。<br>       write:一个正则表达式match哪些配置资源能够被该用户读。<br>       read:一个正则表达式match哪些配置资源能够被该用户访问。<br>   例如：<br><code>rabbitmqctl set_permissions -p / root &#39;.*&#39; &#39;.*&#39; &#39;.*&#39;</code><br>   用于设置root用户拥有对所有资源的 读写配置权限<br>2. 查看用户权限 <code>rabbitmqctl  list_permissions [vhostpath]</code><br>例如<br>  查看根径经下的所有用户权限<br>  <code>rabbitmqctl  list_permissions</code><br>  查看指定命名空间下的所有用户权限<br> <code>rabbitmqctl  list_permissions /abc</code><br>3. 查看指定用户下的权限<code>rabbitmqctl  list_user_permissions {username}</code><br>例如<br>  查看root用户下的权限<br> <code>rabbitmqctl  list_user_permissions root</code><br>4. 清除用户权限<code>rabbitmqctl  clear_permissions {username}</code><br>例如：<br>    清除root用户的权限<br><code>rabbitmqctl  clear_permissions root</code></p><h3 id="1-3-5-vhost管理"><a href="#1-3-5-vhost管理" class="headerlink" title="1.3.5 vhost管理"></a>1.3.5 vhost管理</h3><p> vhost是RabbitMQ中的一个命名空间，可以限制消息的存放位置利用这个命名空间可以进行权限的控制有点类似Windows中的文件夹一样，在不同的文件夹中存放不同的文件。</p><ol><li>添加vhost: rabbitmqctl add vhost {name}<br>例如<br><code>rabbitmqctl add vhost bjpowernode</code></li><li>删除vhost：rabbitmqctl delete vhost {name}<br>例如<br> <code>rabbitmqctl delete vhost bjpowernode</code></li></ol><blockquote><p>至此，以上便是-RabbitMQ消息队列|从入门到精通——RabbitMQ的安装与启动-的全部内容<br>我是石乔，一个尚在努力着的Java程序员<br>愿我的文章可以帮助到你，共同努力，加油！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第1章-RabbitMQ安装&quot;&gt;&lt;a href=&quot;#第1章-RabbitMQ安装&quot; class=&quot;headerlink&quot; title=&quot;第1章 RabbitMQ安装&quot;&gt;&lt;/a&gt;第1章 RabbitMQ安装&lt;/h1&gt;&lt;p&gt;一般来说安装RabbitMQ之前要安装Erlang，可以去Erlang官网下载。&lt;br&gt;接着去RabbitMQ官网下载安装包，之后解压缩即可。&lt;br&gt;Erlang官方下载地址：&lt;a href=&quot;https://www.erlang.org/downloads&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.erlang.org/downloads&lt;/a&gt;&lt;br&gt;RabbitMQ官方下载地址：&lt;a href=&quot;https://www.rabbitmq.com/download.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.rabbitmq.com/download.html&lt;/a&gt;&lt;br&gt;不方便去官网下载的可以去&lt;a href=&quot;https://pan.baidu.com/s/1fg7XIySTHpL1KltmJ-Wjjg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;百度网盘下载&lt;/a&gt;  提取码：cweu&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200327202438625.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-1-安装前的准备&quot;&gt;&lt;a href=&quot;#1-1-安装前的准备&quot; class=&quot;headerlink&quot; title=&quot;1.1 安装前的准备&quot;&gt;&lt;/a&gt;1.1 安装前的准备&lt;/h2&gt;&lt;h3 id=&quot;1-1-1-依赖包安装&quot;&gt;&lt;a href=&quot;#1-1-1-依赖包安装&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 依赖包安装&quot;&gt;&lt;/a&gt;1.1.1 依赖包安装&lt;/h3&gt;&lt;p&gt;安装RabbitMQ之前必须要先安装所需要的依赖包，可以使用下面的一次性安装命令：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum install gcc glibc-devel make ncurses-devel openssl-devel xmlto&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>springboot项目打成war包并部署到Linux的Tomcat中</title>
    <link href="https://heisq.top/posts/9da0efe6.html"/>
    <id>https://heisq.top/posts/9da0efe6.html</id>
    <published>2020-03-17T07:30:16.000Z</published>
    <updated>2020-03-27T12:48:41.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="启动类继承SpringBootServletInitializer"><a href="#启动类继承SpringBootServletInitializer" class="headerlink" title="启动类继承SpringBootServletInitializer"></a>启动类继承<code>SpringBootServletInitializer</code></h2><ol><li><p>打开你的Application启动类</p></li><li><p>在类目后面继承 SpringBootServletInitializer</p></li><li><p>并重写 configure 方法<br><img src="https://img-blog.csdnimg.cn/20200317142044857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlaVNR,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="pom文件添加-lt-packaging-gt-war-lt-packaging-gt"><a href="#pom文件添加-lt-packaging-gt-war-lt-packaging-gt" class="headerlink" title="pom文件添加&lt; packaging&gt;war&lt; /packaging&gt;"></a>pom文件添加<code>&lt; packaging&gt;war&lt; /packaging&gt;</code></h2></li><li><p>打开你的pom.xml，添加下面的标签</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;packaging&gt;war&lt;/packaging&gt;</span><br></pre></td></tr></table></figure><a id="more"></a></li></ol><h2 id="mvn命令操作（clean、install）"><a href="#mvn命令操作（clean、install）" class="headerlink" title="mvn命令操作（clean、install）"></a>mvn命令操作（clean、install）</h2><ol start="6"><li>第五条步骤执行好后，先clean一下当前项目，之后再执行install</li><li>执行完成后 下方会提示是否成功  箭头所指位置如果提示 SUCCESS 即为打包成功</li><li>打包好的war包会存放到项目的target目录<br><img src="https://img-blog.csdnimg.cn/20200317143342319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlaVNR,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><h2 id="打好的war包部署到Linux的Tomcat中"><a href="#打好的war包部署到Linux的Tomcat中" class="headerlink" title="打好的war包部署到Linux的Tomcat中"></a>打好的war包部署到Linux的Tomcat中</h2><ol><li>连接好Linux后进入Tomcat的webapps目录中</li><li>将war包上传进/webapps/中</li><li>上传完进入Tomcat的bin目录</li><li>执行下面命令启动Tomcat</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./startup.sh | tail -f ../logs/catalina.out &amp;</span><br></pre></td></tr></table></figure><h2 id="本地访问部署好的项目"><a href="#本地访问部署好的项目" class="headerlink" title="本地访问部署好的项目"></a>本地访问部署好的项目</h2><ol><li>在本地浏览器访问Linux中部署的项目： </li><li>格式：Linux的ip：Tomcat端口号/web文件夹名</li><li>例如：<a href="http://172.16.1XX.XX3:8082/p2p-web/index" target="_blank" rel="noopener">http://172.16.1XX.XX3:8082/p2p-web/index</a><br><img src="https://img-blog.csdnimg.cn/20200317151119854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlaVNR,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;启动类继承SpringBootServletInitializer&quot;&gt;&lt;a href=&quot;#启动类继承SpringBootServletInitializer&quot; class=&quot;headerlink&quot; title=&quot;启动类继承SpringBootServletInitializer&quot;&gt;&lt;/a&gt;启动类继承&lt;code&gt;SpringBootServletInitializer&lt;/code&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;打开你的Application启动类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在类目后面继承 SpringBootServletInitializer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;并重写 configure 方法&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200317142044857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlaVNR,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;pom文件添加-lt-packaging-gt-war-lt-packaging-gt&quot;&gt;&lt;a href=&quot;#pom文件添加-lt-packaging-gt-war-lt-packaging-gt&quot; class=&quot;headerlink&quot; title=&quot;pom文件添加&amp;lt; packaging&amp;gt;war&amp;lt; /packaging&amp;gt;&quot;&gt;&lt;/a&gt;pom文件添加&lt;code&gt;&amp;lt; packaging&amp;gt;war&amp;lt; /packaging&amp;gt;&lt;/code&gt;&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;打开你的pom.xml，添加下面的标签&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java技术相关" scheme="https://heisq.top/categories/Java%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Java" scheme="https://heisq.top/tags/Java/"/>
    
      <category term="Linux" scheme="https://heisq.top/tags/Linux/"/>
    
      <category term="Tomcat" scheme="https://heisq.top/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>前言</title>
    <link href="https://heisq.top/posts/7819a34e.html"/>
    <id>https://heisq.top/posts/7819a34e.html</id>
    <published>2019-12-30T07:14:27.000Z</published>
    <updated>2020-03-17T11:34:05.019Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><h2>你好，来访者</h2><h2>这是一篇测试文章</h2><h2>内容有待填充</h2><h2>精彩文章，敬请期待</h2><img src="/posts/7819a34e/heibai.jpg" class="" title="This is an image">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;前言&lt;/h1&gt;

&lt;h2&gt;你好，来访者&lt;/h2&gt;
&lt;h2&gt;这是一篇测试文章&lt;/h2&gt;
&lt;h2&gt;内容有待填充&lt;/h2&gt;
&lt;h2&gt;精彩文章，敬请期待&lt;/h2&gt;
&lt;img src=&quot;/posts/7819a34e/heibai.jpg&quot; class=&quot;&quot; title=&quot;This
      
    
    </summary>
    
    
      <category term="闲杂文章" scheme="https://heisq.top/categories/%E9%97%B2%E6%9D%82%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="前言" scheme="https://heisq.top/tags/%E5%89%8D%E8%A8%80/"/>
    
      <category term="你好，来访者" scheme="https://heisq.top/tags/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%9D%A5%E8%AE%BF%E8%80%85/"/>
    
  </entry>
  
  <entry>
    <title>第一篇文章</title>
    <link href="https://heisq.top/posts/5c2fafc7.html"/>
    <id>https://heisq.top/posts/5c2fafc7.html</id>
    <published>2019-12-28T05:26:07.000Z</published>
    <updated>2019-12-30T07:09:36.769Z</updated>
    
    <content type="html"><![CDATA[<h2>你好,这是测试文章</h2><h2>时间：下午03:18</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;你好,这是测试文章&lt;/h2&gt;
&lt;h2&gt;时间：下午03:18&lt;/h2&gt;

      
    
    </summary>
    
    
      <category term="闲杂文章" scheme="https://heisq.top/categories/%E9%97%B2%E6%9D%82%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="你好" scheme="https://heisq.top/tags/%E4%BD%A0%E5%A5%BD/"/>
    
      <category term="来访者" scheme="https://heisq.top/tags/%E6%9D%A5%E8%AE%BF%E8%80%85/"/>
    
  </entry>
  
</feed>
